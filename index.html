<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Extraer texto de imagen (OCR con Tesseract.js)</title>
  <link rel="preconnect" href="https://unpkg.com">
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; padding: 1rem; background: #f6f7f9; color: #111; }
    .app { max-width: 900px; margin: 0 auto; background: #fff; border-radius: 12px; padding: 1rem; box-shadow: 0 6px 30px rgba(0,0,0,.06); }
    header { display: flex; align-items: center; gap: .5rem; margin-bottom: 1rem; }
    h1 { font-size: 1.25rem; margin: 0; }
    .controls { display: grid; gap: .75rem; grid-template-columns: 1fr; }
    .row { display: flex; flex-wrap: wrap; gap: .5rem; align-items: center; }
    label { font-weight: 600; }
    input[type="file"], input[type="url"], select, button, textarea {
      padding: .6rem .7rem; border: 1px solid #dfe3e6; border-radius: 10px; background: #fff; font-size: 1rem;
    }
    button { cursor: pointer; }
    button.primary { background: #111; color: #fff; border: none; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .dropzone {
      border: 2px dashed #c7ccd1; border-radius: 12px; padding: 1rem; text-align: center; color: #555; background: #fafbfc;
    }
    .dropzone.drag { background: #eef6ff; border-color: #77aaff; }
    .preview-wrap { display: grid; grid-template-columns: 1fr; gap: .75rem; margin-top: 1rem; }
    .preview { width: 100%; max-height: 360px; object-fit: contain; border-radius: 10px; background: #f0f2f5; }
    progress { width: 100%; height: 14px; }
    .out { display: grid; gap: .5rem; margin-top: 1rem; }
    textarea { width: 100%; min-height: 180px; resize: vertical; }
    small.hint { color: #666; }
    footer { margin-top: 1rem; color: #667; font-size: .9rem; }
    @media (min-width: 840px) {
      .controls { grid-template-columns: 1fr 1fr; align-items: start; }
      .preview-wrap { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="OCR en el navegador con Tesseract.js">
    <header>
      <h1>Extraer texto de imagen (OCR)</h1>
    </header>

    <div class="controls" id="controls">
      <div>
        <div class="row" aria-live="polite">
          <label for="lang">Idioma del texto</label>
          <select id="lang" title="Selecciona idioma">
            <option value="spa" selected>Espa√±ol (spa)</option>
            <option value="eng">Ingl√©s (eng)</option>
            <option value="por">Portugu√©s (por)</option>
            <option value="fra">Franc√©s (fra)</option>
            <option value="deu">Alem√°n (deu)</option>
            <option value="ita">Italiano (ita)</option>
            <option value="cat">Catal√°n (cat)</option>
          </select>
        </div>

        <div class="row">
          <label for="file">Imagen</label>
          <input id="file" type="file" accept="image/*" capture="environment" />
          <button id="pasteBtn" type="button">Pegar desde portapapeles</button>
        </div>

        <div class="row">
          <label for="url">o URL de imagen</label>
          <input id="url" type="url" placeholder="https://..." />
          <button id="loadUrl" type="button">Cargar</button>
        </div>

        <div class="dropzone" id="dropzone" tabindex="0" aria-label="Arrastra y suelta una imagen aqu√≠">
          Arrastra y suelta una imagen aqu√≠ (o haz clic para seleccionar)
        </div>

        <div class="row">
          <button id="run" class="primary" type="button">Reconocer texto</button>
          <button id="clear" type="button">Limpiar</button>
        </div>

        <div class="row">
          <label for="psm">Modo de segmentaci√≥n (PSM)</label>
          <select id="psm" title="Tesseract Page Segmentation Mode">
            <option value="3" selected>3 ‚Äì Autom√°tico (p√°gina completa)</option>
            <option value="6">6 ‚Äì Bloques uniformes de texto</option>
            <option value="7">7 ‚Äì Una sola l√≠nea</option>
            <option value="8">8 ‚Äì Una sola palabra</option>
            <option value="13">13 ‚Äì L√≠nea raw, sin OSD</option>
          </select>
          <small class="hint">√ötil si el resultado no es preciso.</small>
        </div>
      </div>

      <div>
        <div class="preview-wrap">
          <img id="preview" class="preview" alt="Vista previa de la imagen" />
          <div>
            <label for="progress">Progreso</label>
            <progress id="progress" max="1" value="0" aria-live="polite"></progress>
            <div id="status" class="small hint">Listo.</div>
          </div>
        </div>
        <div class="out">
          <label for="output">Texto extra√≠do</label>
          <textarea id="output" placeholder="Aqu√≠ aparecer√° el texto‚Ä¶"></textarea>
          <button id="copy" type="button">Copiar texto</button>
        </div>
      </div>
    </div>

    <footer>
      Consejos: obtendr√°s mejores resultados con im√°genes n√≠tidas, bien iluminadas y con el texto en horizontal.
    </footer>
  </div>

  <!-- Tesseract.js desde CDN -->
  <script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
  <script>
    const $ = (id) => document.getElementById(id);
    const fileInput = $('file');
    const dropzone = $('dropzone');
    const preview = $('preview');
    const runBtn = $('run');
    const clearBtn = $('clear');
    const progressEl = $('progress');
    const statusEl = $('status');
    const output = $('output');
    const copyBtn = $('copy');
    const langSel = $('lang');
    const urlInput = $('url');
    const loadUrlBtn = $('loadUrl');
    const pasteBtn = $('pasteBtn');
    const psmSel = $('psm');

    // Si no tienes U() definida en tu proyecto, usa esta identidad
    window.U = window.U || function(x){ return (x ?? '').toString(); };

    let currentBlob = null;

    function setStatus(msg) { statusEl.textContent = msg; }
    function setProgress(v) { progressEl.value = v; }

    function blobFromUrl(url) {
      return fetch(url, { mode: 'cors' })
        .then(r => {
          if (!r.ok) throw new Error('No se pudo cargar la imagen.');
          return r.blob();
        });
    }

    function updatePreviewFromBlob(blob) {
      currentBlob = blob;
      const url = URL.createObjectURL(blob);
      preview.src = url;
      setStatus('Imagen cargada.');
    }

    fileInput.addEventListener('change', () => {
      const f = fileInput.files?.[0];
      if (f) updatePreviewFromBlob(f);
    });

    // Drag & drop
    ;['dragenter','dragover'].forEach(ev =>
      dropzone.addEventListener(ev, e => { e.preventDefault(); dropzone.classList.add('drag'); })
    );
    ;['dragleave','drop'].forEach(ev =>
      dropzone.addEventListener(ev, e => { e.preventDefault(); dropzone.classList.remove('drag'); })
    );
    dropzone.addEventListener('drop', e => {
      const f = e.dataTransfer.files?.[0];
      if (f) updatePreviewFromBlob(f);
    });
    dropzone.addEventListener('click', () => fileInput.click());

    // Cargar desde URL
    loadUrlBtn.addEventListener('click', async () => {
      const url = urlInput.value.trim();
      if (!url) return;
      try {
        setStatus('Cargando imagen desde URL‚Ä¶');
        const blob = await blobFromUrl(url);
        updatePreviewFromBlob(blob);
      } catch (err) {
        setStatus('Error: ' + err.message);
      }
    });

    // Pegar desde portapapeles
    pasteBtn.addEventListener('click', async () => {
      try {
        const items = await navigator.clipboard.read();
        for (const item of items) {
          for (const type of item.types) {
            if (type.startsWith('image/')) {
              const blob = await item.getType(type);
              return updatePreviewFromBlob(blob);
            }
          }
        }
        setStatus('No se encontr√≥ imagen en el portapapeles.');
      } catch (_) {
        setStatus('Tu navegador no permite pegar im√°genes desde el portapapeles.');
      }
    });

    // Copiar resultado
    copyBtn.addEventListener('click', async () => {
      try { await navigator.clipboard.writeText(output.value || ''); setStatus('Texto copiado.'); }
      catch { setStatus('No se pudo copiar.'); }
    });

    clearBtn.addEventListener('click', () => {
      currentBlob = null;
      preview.removeAttribute('src');
      output.value = '';
      setProgress(0); setStatus('Listo.');
      fileInput.value = ''; urlInput.value = '';
    });

    /******************************************************
     *  üîé Normalizaci√≥n + mapeo multiling√ºe + extracci√≥n
     ******************************************************/
    const CANON = {
      DOCUMENT_TYPE: 'TIPO DOCUMENTO',
      DOCUMENT_NUMBER: 'N¬∫DOCUMENTO', // atendemos tu clave exacta
      SEX: 'SEXO',
      NATIONALITY: 'NACIONALIDAD',
      NAME: 'NOMBRE',
      SURNAME: 'APELLIDOS',
      PARENTS_NAMES: 'Nombre de los Padres',
      DOB: 'FECHA DE NACIMIENTO',
      POB: 'LUGAR DE NACIMIENTO',
      ADDRESS: 'DOMICILIO',
      FATHER_NAME: 'FATHER_NAME',   // internos
      MOTHER_NAME: 'MOTHER_NAME'
    };

    // etiquetas por idioma (solo las necesarias para tus 10 campos)
    const LABELS = {
      es: {
        DOCUMENT_TYPE: ['TIPO DE DOCUMENTO','TIPO DOCUMENTO','CLASE DOCUMENTO','DOCUMENTO'],
        DOCUMENT_NUMBER: ['N√öMERO DE DOCUMENTO','NUMERO DE DOCUMENTO','N¬∫ DOCUMENTO','N¬∞ DOCUMENTO','N. DOCUMENTO','NO. DOCUMENTO','NUM. DOCUMENTO','NUMERO','N√öMERO','ID'],
        SEX: ['SEXO','G√âNERO','GENERO'],
        NATIONALITY: ['NACIONALIDAD','CIUDADAN√çA','CIUDADANIA'],
        NAME: ['NOMBRE','NOMBRES'],
        SURNAME: ['APELLIDO','APELLIDOS','PRIMER APELLIDO','SEGUNDO APELLIDO'],
        PARENTS_NAMES: ['NOMBRE DE LOS PADRES','PADRES','PADRE Y MADRE','NOMBRE DEL PADRE Y DE LA MADRE'],
        DOB: ['FECHA DE NACIMIENTO','FEC. NAC.','NACIMIENTO'],
        POB: ['LUGAR DE NACIMIENTO','CIUDAD DE NACIMIENTO','PA√çS DE NACIMIENTO','PAIS DE NACIMIENTO'],
        ADDRESS: ['DOMICILIO','DIRECCI√ìN','DIRECCION','RESIDENCIA','DOMICILIO HABITUAL','LUGAR DE RESIDENCIA'],
        FATHER_NAME: ['NOMBRE DEL PADRE','PADRE'],
        MOTHER_NAME: ['NOMBRE DE LA MADRE','MADRE']
      },
      en: {
        DOCUMENT_TYPE: ['DOCUMENT TYPE','TYPE OF DOCUMENT','DOCUMENT'],
        DOCUMENT_NUMBER: ['DOCUMENT NUMBER','DOC NUMBER','DOC NO','ID NUMBER','ID NO','NUMBER','NO.'],
        SEX: ['SEX','GENDER'],
        NATIONALITY: ['NATIONALITY','CITIZENSHIP'],
        NAME: ['NAME','GIVEN NAME','GIVEN NAMES','FORENAME','FORENAMES','FIRST NAME'],
        SURNAME: ['SURNAME','FAMILY NAME','LAST NAME'],
        PARENTS_NAMES: ['PARENTS‚Äô NAMES','PARENTS\' NAMES','PARENTS'],
        DOB: ['DATE OF BIRTH','BIRTHDATE','DOB'],
        POB: ['PLACE OF BIRTH','CITY OF BIRTH','COUNTRY OF BIRTH'],
        ADDRESS: ['ADDRESS','RESIDENCE','RESIDENTIAL ADDRESS','HOME ADDRESS','MAILING ADDRESS'],
        FATHER_NAME: ['FATHER‚ÄôS NAME','FATHER NAME'],
        MOTHER_NAME: ['MOTHER‚ÄôS NAME','MOTHER NAME']
      },
      fr: {
        DOCUMENT_TYPE: ['TYPE DE DOCUMENT','DOCUMENT','DOCUMENT D‚ÄôIDENTIT√â','DOCUMENT D\'IDENTITE'],
        DOCUMENT_NUMBER: ['NUM√âRO DE DOCUMENT','NUMERO DE DOCUMENT','N¬∞','NO','NUM.'],
        SEX: ['SEXE'],
        NATIONALITY: ['NATIONALIT√â','NATIONALITE','CITOYENNET√â','CITOYENNETE'],
        NAME: ['PR√âNOM','PRENOM','PR√âNOMS','PRENOMS'],
        SURNAME: ['NOM','NOM DE FAMILLE'],
        PARENTS_NAMES: ['NOMS DES PARENTS','P√àRE ET M√àRE','PERE ET MERE'],
        DOB: ['DATE DE NAISSANCE'],
        POB: ['LIEU DE NAISSANCE','VILLE DE NAISSANCE','PAYS DE NAISSANCE'],
        ADDRESS: ['ADRESSE','R√âSIDENCE','RESIDENCE','LIEU DE R√âSIDENCE'],
        FATHER_NAME: ['NOM DU P√àRE','NOM DU PERE'],
        MOTHER_NAME: ['NOM DE LA M√àRE','NOM DE LA MERE']
      },
      de: {
        DOCUMENT_TYPE: ['DOKUMENTENTYP','ART DES DOKUMENTS','DOKUMENT','AUSWEISART'],
        DOCUMENT_NUMBER: ['DOKUMENTNUMMER','AUSWEISNUMMER','PASSNUMMER','NR.','NUMMER'],
        SEX: ['GESCHLECHT'],
        NATIONALITY: ['STAATSANGEH√ñRIGKEIT','STAATSANGEHOERIGKEIT'],
        NAME: ['VORNAME','VORNAMEN'],
        SURNAME: ['NACHNAME','FAMILIENNAME'],
        PARENTS_NAMES: ['NAME DER ELTERN','ELTERN'],
        DOB: ['GEBURTSDATUM'],
        POB: ['GEBURTSORT','STADT DER GEBURT','LAND DER GEBURT'],
        ADDRESS: ['ANSCHRIFT','WOHNSITZ','WOHNORT','AUFENTHALTSORT'],
        FATHER_NAME: ['NAME DES VATERS'],
        MOTHER_NAME: ['NAME DER MUTTER']
      },
      it: {
        DOCUMENT_TYPE: ['TIPO DI DOCUMENTO','TIPO DOCUMENTO','DOCUMENTO'],
        DOCUMENT_NUMBER: ['NUMERO DOCUMENTO','N.','NR','NUM.','N¬∞','N¬∫'],
        SEX: ['SESSO'],
        NATIONALITY: ['NAZIONALIT√Ä','NAZIONALITA','CITTADINANZA'],
        NAME: ['NOME','PRENOME'],
        SURNAME: ['COGNOME'],
        PARENTS_NAMES: ['NOMI DEI GENITORI','GENITORI'],
        DOB: ['DATA DI NASCITA'],
        POB: ['LUOGO DI NASCITA','CITT√Ä DI NASCITA','PAESE DI NASCITA','CITTA DI NASCITA'],
        ADDRESS: ['INDIRIZZO','RESIDENZA','DOMICILIO','INDIRIZZO DI RESIDENZA'],
        FATHER_NAME: ['NOME DEL PADRE'],
        MOTHER_NAME: ['NOME DELLA MADRE']
      },
      pt: {
        DOCUMENT_TYPE: ['TIPO DE DOCUMENTO','DOCUMENTO','DOCUMENTO DE IDENTIDADE'],
        DOCUMENT_NUMBER: ['N√öMERO DO DOCUMENTO','NUMERO DO DOCUMENTO','N¬∫','N¬∞','N.','NO.','NUM.'],
        SEX: ['SEXO','G√âNERO','GENERO'],
        NATIONALITY: ['NACIONALIDADE','CIDADANIA'],
        NAME: ['NOME','PR√â-NOME','PRE-NOME'],
        SURNAME: ['SOBRENOME','APELIDO'],
        PARENTS_NAMES: ['NOMES DOS PAIS','PAIS'],
        DOB: ['DATA DE NASCIMENTO'],
        POB: ['LOCAL DE NASCIMENTO','CIDADE DE NASCIMENTO','PA√çS DE NASCIMENTO','PAIS DE NASCIMENTO'],
        ADDRESS: ['MORADA','ENDERE√áO','RESID√äNCIA','DOMIC√çLIO','DOMICILIO','ENDERE√áO RESIDENCIAL'],
        FATHER_NAME: ['NOME DO PAI'],
        MOTHER_NAME: ['NOME DA M√ÉE','NOME DA MAE','MAE','M√ÉE']
      },
      ro: {
        DOCUMENT_TYPE: ['TIP DOCUMENT','TIPUL DOCUMENTULUI','DOCUMENT','ACT DE IDENTITATE'],
        DOCUMENT_NUMBER: ['NUMƒÇR DOCUMENT','NUMAR DOCUMENT','NR. DOCUMENT','NR DOCUMENT','NR.','NR','NUMAR','NUMƒÇR'],
        SEX: ['SEX'],
        NATIONALITY: ['NA»öIONALITATE','NATIONALITATE','CETƒÇ»öENIE','CETATENIE'],
        NAME: ['PRENUME','PRENUMELE'],          // nombre(s)
        SURNAME: ['NUME','NUMELE'],             // apellido
        PARENTS_NAMES: ['NUMELE PƒÇRIN»öILOR','NUMELE PARINTILOR','PƒÇRIN»öI','PARINTI'],
        DOB: ['DATA NA»òTERII','DATA NASTERII'],
        POB: ['LOCUL NA»òTERII','LOCUL NASTERII','ORA»òUL NA»òTERII','ORASUL NASTERII','»öARA NA»òTERII','TARA NASTERII'],
        ADDRESS: ['DOMICILIU','ADRESƒÇ','ADRESA','RE»òEDIN»öƒÇ','RESEDINTA'],
        FATHER_NAME: ['NUMELE TATƒÇLUI','NUMELE TATALUI'],
        MOTHER_NAME: ['NUMELE MAMEI']
      }
    };

    // sin√≥nimos cross-idioma para robustez
    const CROSS = {
      NAME: ['NOME','NAME','NOMBRE','NOM','VORNAME','PRENOME','PR√âNOM','PRENOM','PRENUME','GIVEN NAME','FIRST NAME'],
      SURNAME: ['SURNAME','FAMILY NAME','LAST NAME','APELLIDO','APELLIDOS','NACHNAME','COGNOME','NOM DE FAMILLE','NUME'],
      DOCUMENT_NUMBER: ['DOC NO','DOC NUMBER','ID NUMBER','NUMERO DOCUMENTO','DOKUMENTNUMMER','AUSWEISNUMMER','NUM√âRO DE DOCUMENT','N¬∫','N¬∞','NR.','NO.','NUM.','NR'],
      ADDRESS: ['ADDRESS','ADRESSE','ANSCHRIFT','INDIRIZZO','ENDERE√áO','DIRECCION','DIRECCI√ìN','DOMICILIO','RESIDENCIA','MORADA','ADRESƒÇ','ADRESA','DOMICILIU','RE»òEDIN»öƒÇ','RESEDINTA'],
      NATIONALITY: ['NATIONALITY','CITIZENSHIP','NATIONALIT√â','STAATSANGEH√ñRIGKEIT','NAZIONALIT√Ä','NACIONALIDADE','NA»öIONALITATE','CETƒÇ»öENIE'],
      SEX: ['SEX','GENDER','SEXE','GESCHLECHT','SESSO','SEXO'],
      DOB: ['DATE OF BIRTH','DOB','FECHA DE NACIMIENTO','DATE DE NAISSANCE','GEBURTSDATUM','DATA DI NASCITA','DATA DE NASCIMENTO','DATA NA»òTERII'],
      POB: ['PLACE OF BIRTH','LUGAR DE NACIMIENTO','LIEU DE NAISSANCE','GEBURTSORT','LUOGO DI NASCITA','LOCAL DE NASCIMENTO','LOCUL NA»òTERII'],
      PARENTS_NAMES: [
        'PARENTS‚Äô NAMES','NOMBRE DE LOS PADRES','NOMS DES PARENTS','NAME DER ELTERN','NOMI DEI GENITORI','NOMES DOS PAIS',
        'FATHER‚ÄôS NAME','MOTHER‚ÄôS NAME','NOM DU P√àRE','NOM DE LA M√àRE','NAME DES VATERS','NAME DER MUTTER',
        'NOME DEL PADRE','NOME DELLA MADRE','NOME DO PAI','NOME DA M√ÉE','NUMELE PƒÇRIN»öILOR','NUMELE TATƒÇLUI','NUMELE MAMEI'
      ],
      FATHER_NAME: ['FATHER‚ÄôS NAME','NOM DU P√àRE','NAME DES VATERS','NOME DEL PADRE','NOME DO PAI','NUMELE TATƒÇLUI'],
      MOTHER_NAME: ['MOTHER‚ÄôS NAME','NOM DE LA M√àRE','NAME DER MUTTER','NOME DELLA MADRE','NOME DA M√ÉE','NUMELE MAMEI']
    };

    const NORM = s => (s??'')
      .normalize('NFD').replace(/\p{Diacritic}/gu,'')
      .replace(/[^\p{L}\p{N}\s.:/-]/gu,'')
      .replace(/\s+/g,' ')
      .trim()
      .toUpperCase();

    function lev(a,b){a=a||'';b=b||'';const m=a.length,n=b.length;if(!m)return n;if(!n)return m;
      const dp=new Array(n+1);for(let j=0;j<=n;j++)dp[j]=j;
      for(let i=1;i<=m;i++){let prev=dp[0];dp[0]=i;for(let j=1;j<=n;j++){const t=dp[j];
        const c=a[i-1]===b[j-1]?0:1;dp[j]=Math.min(dp[j]+1,dp[j-1]+1,prev+c);prev=t;}}return dp[n];}

    function buildREV(){
      const rev = new Map();
      for(const [lang,groups] of Object.entries(LABELS)){
        for(const [canonKey,arr] of Object.entries(groups)){
          for(const raw of arr){ rev.set(NORM(raw), {canonKey, lang}); }
        }
      }
      for(const [canonKey,arr] of Object.entries(CROSS)){
        for(const raw of arr){ const k=NORM(raw); if(!rev.has(k)) rev.set(k,{canonKey, lang:'multi'}); }
      }
      return rev;
    }
    const REV = buildREV();

    function detectLangByContext(words){
      const tally = { es:0,en:0,fr:0,de:0,it:0,pt:0,ro:0 };
      for(const w of (words||[])){
        const t = NORM(w.text||'').replace(/[:.]$/,'');
        const hit = REV.get(t); if(!hit) continue;
        if(tally[hit.lang]!=null) tally[hit.lang]++;
      }
      let best=null,bestv=0; for(const [k,v] of Object.entries(tally)){ if(v>bestv){best=k;bestv=v;} }
      return bestv>0?best:null;
    }

    function mapTokenToCanon(token, preferLang=null){
      const T0 = NORM(token).replace(/[:.]$/,'');
      const exact = REV.get(T0);
      if(exact){ return { canon: CANON[exact.canonKey]||exact.canonKey, lang: exact.lang, score: 0, via: 'exact' }; }

      let best = {canon:null,score:Infinity,lang:null,via:null};
      const candidates=[];

      if(preferLang && LABELS[preferLang]){
        for(const [canonKey,arr] of Object.entries(LABELS[preferLang])){
          for(const raw of arr) candidates.push({canonKey,lang:preferLang,raw});
        }
      }
      for(const [canonKey,arr] of Object.entries(CROSS)){
        for(const raw of arr) candidates.push({canonKey,lang:'multi',raw});
      }

      const Tclean = T0.replace(/0/g,'O').replace(/1/g,'I').replace(/5/g,'S').replace(/8/g,'B').replace(/RN/g,'M');

      for(const c of candidates){
        const R = NORM(c.raw);
        const dist = Math.min(lev(T0,R), lev(Tclean,R));
        const penalty = (preferLang && c.lang!==preferLang)?0.5:0;
        const rel = (dist/Math.max(3,R.length)) + penalty;
        if(rel < best.score){ best = { canon: CANON[c.canonKey]||c.canonKey, score: rel, lang:c.lang, via:'fuzzy' }; }
      }
      if(best.canon && best.score<=0.45) return best;
      return { canon:null, score:1e9, lang:null, via:null };
    }

    function groupByLine(words, tolerance=8){
      const rows=[];
      const sorted=(words||[]).filter(w=>(w.text||'').trim()).map(w=>({...w,y:w.bbox?.y0??0,x:w.bbox?.x0??0}))
        .sort((a,b)=> a.y-b.y || a.x-b.x);
      for(const w of sorted){
        const row = rows.find(r=>Math.abs(r.y-w.y)<=tolerance);
        if(row){ row.items.push(w); row.y=(row.y+w.y)/2; }
        else rows.push({y:w.y, items:[w]});
      }
      for(const r of rows) r.items.sort((a,b)=>a.x-b.x);
      return rows;
    }

    function isLabelToken(t){
      if(!t) return false;
      const T=NORM(t);
      if(REV.has(T)) return true;
      return REV.has(T.replace(/[:.]$/,''));
    }

    function pickValueRightOf(labelWord, row, rows){
      const same=row.items;
      const idx=same.indexOf(labelWord);
      let candidates=same.slice(idx+1);
      if(candidates.length===0 || (candidates[0].x - labelWord.x) > 400){
        const rowIdx=rows.indexOf(row);
        if(rows[rowIdx+1]) candidates = rows[rowIdx+1].items;
      }
      const out=[];
      for(const w of candidates){
        const t=(w.text||'').trim();
        if(!t) continue;
        if(isLabelToken(t)) break;
        if(/^[,;:]+$/.test(t)) continue;
        out.push(t);
        if(out.length>=6) break; // suficiente para nombres/apellidos compuestos o direcci√≥n corta
      }
      return out.join(' ').trim();
    }

    function unirApellidos(acc){
      const list = acc.__apellidos || [];
      const val = list.join(' ').replace(/\s+/g,' ').trim();
      return val;
    }

    function extractFields(data){
      const words = data.words || [];
      const preferLang = detectLangByContext(words);
      const rows = groupByLine(words);
      const acc = {
        [CANON.NAME]: '',
        __apellidos: [],
        [CANON.PARENTS_NAMES]: '',
        [CANON.DOCUMENT_TYPE]: '',
        [CANON.DOCUMENT_NUMBER]: '',
        [CANON.SEX]: '',
        [CANON.NATIONALITY]: '',
        [CANON.DOB]: '',
        [CANON.POB]: '',
        [CANON.ADDRESS]: '',
        [CANON.FATHER_NAME]: '',
        [CANON.MOTHER_NAME]: ''
      };

      for(const row of rows){
        for(const w of row.items){
          const raw=(w.text||'').trim();
          if(!raw || !isLabelToken(raw)) continue;

          const map = mapTokenToCanon(raw, preferLang);
          if(!map.canon) continue;

          const value = pickValueRightOf(w, row, rows);
          if(!value) continue;

          const VAL = value
            .replace(/rn/g,'m')
            .replace(/(^|[^A-Z])0(?=[A-Z]|$)/g,'$1O')
            .replace(/(^|[^A-Z])1(?=[A-Z]|$)/g,'$1I');

          if(map.canon === CANON.NAME){
            if(!acc[CANON.NAME]) acc[CANON.NAME]=VAL;
          } else if(map.canon === CANON.SURNAME){
            acc.__apellidos.push(VAL);
          } else if(map.canon === CANON.PARENTS_NAMES){
            if(!acc[CANON.PARENTS_NAMES]) acc[CANON.PARENTS_NAMES]=VAL;
          } else if(map.canon === CANON.FATHER_NAME){
            acc[CANON.FATHER_NAME]=VAL;
          } else if(map.canon === CANON.MOTHER_NAME){
            acc[CANON.MOTHER_NAME]=VAL;
          } else if(map.canon === CANON.ADDRESS){
            if(!acc[CANON.ADDRESS]) acc[CANON.ADDRESS]=VAL;
          } else {
            if(!acc[map.canon]) acc[map.canon]=VAL;
          }
        }
      }

      // Une apellidos si hay dos o m√°s
      const apellidos = unirApellidos(acc);
      if(apellidos) acc[CANON.SURNAME]=apellidos;

      // Si no hay "Nombre de los Padres" pero s√≠ padre/madre, comb√≠nalos
      if(!acc[CANON.PARENTS_NAMES]){
        const padre = acc[CANON.FATHER_NAME];
        const madre = acc[CANON.MOTHER_NAME];
        const combo = [padre, madre].filter(Boolean).join(' / ');
        if(combo) acc[CANON.PARENTS_NAMES]=combo;
      }

      return { acc, preferLang };
    }

    function buildExport(acc){
      // Construye el objeto con EXACTAMENTE tus claves visibles
      const data = {
        "Nombre": acc[CANON.NAME] || "",
        "APELLIDOS": acc[CANON.SURNAME] || "",
        "TIPO DOCUMENTO": acc[CANON.DOCUMENT_TYPE] || "",
        "N¬∫DOCUMENTO": acc[CANON.DOCUMENT_NUMBER] || acc["NUMERO_DOCUMENTO"] || "",
        "SEXO": acc[CANON.SEX] || "",
        "NACIONALIDAD": acc[CANON.NATIONALITY] || "",
        "Nombre de los Padres": acc[CANON.PARENTS_NAMES] || "",
        "FECHA DE NACIMIENTO": acc[CANON.DOB] || "",
        "LUGAR DE NACIMIENTO": acc[CANON.POB] || "",
        "DOMICILIO": acc[CANON.ADDRESS] || ""
      };

      const domDisplay = data["DOMICILIO"] || "";

      // Array final en el orden que pediste
      const salida = [
        ["Nombre", U(data["Nombre"])],
        ["Apellidos", U(data["APELLIDOS"])],
        ["Tipo de documento", U(data["TIPO DOCUMENTO"])],
        ["N¬∫ Documento", U(data["N¬∫DOCUMENTO"])],
        ["Sexo", U(data["SEXO"])],
        ["Nacionalidad", U(data["NACIONALIDAD"])],
        ["Nombre de los Padres", U(data["Nombre de los Padres"])],
        ["Fecha de nacimiento", U(data["FECHA DE NACIMIENTO"])],
        ["Lugar de nacimiento", U(data["LUGAR DE NACIMIENTO"])],
        ["Domicilio", U(domDisplay)]
      ];

      return { data, salida, domDisplay };
    }

    runBtn.addEventListener('click', async () => {
      if (!currentBlob) return setStatus('Sube o pega una imagen primero.');
      output.value = '';
      setProgress(0); setStatus('Descargando modelos‚Ä¶');

      // Configuraci√≥n Tesseract
      const lang = langSel.value || 'spa';
      const psm = parseInt(psmSel.value, 10);

      try {
        const worker = await Tesseract.createWorker(lang, 1, {
          logger: m => {
            if (m.status === 'recognizing text' && m.progress != null) {
              setStatus('Reconociendo‚Ä¶ ' + Math.round(m.progress * 100) + '%');
              setProgress(m.progress);
            } else if (m.status) {
              setStatus(m.status.charAt(0).toUpperCase() + m.status.slice(1) + '‚Ä¶');
            }
          },
          workerPath: 'https://unpkg.com/tesseract.js@5.1.0/dist/worker.min.js',
          corePath: 'https://unpkg.com/tesseract.js-core@5.0.0/tesseract-core.wasm.js',
        });

        await worker.setParameters({ tessedit_pageseg_mode: psm });

        setStatus('Procesando imagen‚Ä¶');
        const img = currentBlob;

        const { data } = await worker.recognize(img);

        // === Post-proceso: detectar, normalizar y exportar ===
        const { acc } = extractFields(data);
        const { data: exportData, salida } = buildExport(acc);

        // mostramos algo √∫til en la UI:
        output.value =
          '--- Campos normalizados ---\n' +
          JSON.stringify(exportData, null, 2) +
          '\n\n--- Array exportaci√≥n ---\n' +
          JSON.stringify(salida, null, 2);

        setProgress(1); setStatus('Completado ‚úî');

        await worker.terminate();
      } catch (err) {
        console.error(err);
        setStatus('Error durante OCR: ' + (err.message || err));
      }
    });
  </script>
</body>
</html>
